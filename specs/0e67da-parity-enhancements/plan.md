---
runId: 0e67da
feature: parity-enhancements
created: 2025-12-09
status: ready
---

# Feature: TypeScript Parity Enhancements - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/0e67da-parity-enhancements/spec.md
> **Created:** 2025-12-09

## Execution Summary

- **Total Tasks**: 5
- **Total Phases**: 3
- **Sequential Time**: 23h
- **Parallel Time**: 16h
- **Time Savings**: 7h (30% faster)

**Parallel Opportunities:**
- Phase 2: 3 tasks (7h saved)

---

## Phase 1: Foundation - Shared Agent Infrastructure

**Strategy**: sequential
**Reason**: Foundation layer must exist before dependent layers (agent files, CLI) can use the shared utilities

### Task 1.1: Shared Agent Infrastructure & Type Methods

**Files**:
- src/agents/mod.rs
- src/types.rs

**Complexity**: M (4h)

**Dependencies**: None

**Description**:
Extract shared agent utilities to eliminate ~120 lines of duplication across agent files and centralize agent metadata in `AgentName`. This creates the foundation that all agent-specific files will depend on.

**Implementation Steps**:

1. In `src/agents/mod.rs`, add shared infrastructure:
   - Add `pub(crate) const AGENT_TIMEOUT: Duration = Duration::from_secs(120)`
   - Add `check_command_exists(command: &str, agent: AgentName) -> Result<(), AgentError>`
   - Add `run_command_with_stdin(command: &str, args: &[&str], prompt: &str, agent: AgentName) -> Result<String, AgentError>`
   - Use tokio::process::Command for process spawning
   - Write stdin, capture stdout/stderr, map errors to AgentError

2. In `src/types.rs`, add `AgentName` methods:
   - Add `display_name(&self) -> &'static str` (returns "Claude", "Codex", "Gemini")
   - Add `install_url(&self) -> &'static str` (returns installation URLs)
   - Add doc comments for both methods

3. Write unit tests in both modules:
   - Test `AgentName::display_name()` returns correct names
   - Test `AgentName::install_url()` returns valid URLs
   - Test `check_command_exists()` with mock command
   - Test `run_command_with_stdin()` error handling (no integration tests with real agents)

**Acceptance Criteria**:
- [ ] `AGENT_TIMEOUT` constant defined once in `agents/mod.rs`
- [ ] `check_command_exists()` implemented with proper error mapping
- [ ] `run_command_with_stdin()` handles stdin writing and output capture
- [ ] `AgentName::display_name()` returns correct display names
- [ ] `AgentName::install_url()` returns correct URLs
- [ ] All functions have doc comments
- [ ] Unit tests cover success and error cases

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Functions over structs (utility functions in mod.rs, not a struct)
- thiserror for domain errors (AgentError)
- Async for external processes (agent CLI execution)
- See patterns.md for error patterns and async patterns

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
cargo test agents::tests
cargo test types::tests
cargo clippy -- -D warnings
cargo fmt -- --check
```

---

## Phase 2: Core Features - Parallel Implementation

**Strategy**: parallel
**Reason**: These tasks operate on independent files with no overlaps - can execute concurrently

### Task 2.1: Git Diff Optimization & resolve_git_dir Sharing

**Files**:
- src/git.rs
- src/hooks/managers.rs

**Complexity**: M (3h)

**Dependencies**: None

**Description**:
Optimize git diff flags for cleaner, more token-efficient diffs and eliminate duplicate `resolve_git_dir()` implementation by making it public in git.rs and removing the duplicate from hooks/managers.rs.

**Implementation Steps**:

1. In `src/git.rs`, update `RealGitProvider::get_staged_diff()`:
   - Change `["diff", "--cached"]` to `["diff", "--cached", "--unified=3", "--ignore-space-change"]`
   - Add comment explaining why these flags (token efficiency, cleaner diffs)

2. In `src/git.rs`, make `resolve_git_dir()` public:
   - Change visibility from private/pub(crate) to `pub`
   - Add doc comment explaining what it does and why it's public

3. In `src/hooks/managers.rs`, remove duplicate `resolve_git_dir()`:
   - Add `use crate::git::resolve_git_dir;` at top
   - Remove local `resolve_git_dir()` implementation
   - Update calls to use imported function
   - Update error mapping from GitError to HookError as needed

4. Write/update tests:
   - Test that diff flags are included in git command
   - Test that whitespace-only changes are filtered
   - Test that resolve_git_dir works from hooks module

**Acceptance Criteria**:
- [ ] Git diff uses `--unified=3 --ignore-space-change` flags
- [ ] `resolve_git_dir()` is public in git.rs with doc comment
- [ ] Duplicate `resolve_git_dir()` removed from hooks/managers.rs
- [ ] hooks/managers.rs imports and uses git::resolve_git_dir
- [ ] Tests verify correct git command construction
- [ ] Manual test: whitespace-only changes filtered from diff

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- GitProvider trait abstraction (git.rs)
- Sync for local operations (git commands)
- See architecture.md for module responsibilities (Git module)

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
cargo test git::tests
cargo test hooks::tests
cargo clippy -- -D warnings
cargo fmt -- --check
```

### Task 2.2: Prompt Enhancements - Diff Truncation & Change Summary

**Files**:
- src/prompt.rs

**Complexity**: M (4h)

**Dependencies**: None

**Description**:
Add diff truncation to prevent token limit issues and include change summary metadata (file count, lines +/-) to give AI better context about the scope of changes.

**Implementation Steps**:

1. Add constants and truncation function:
   - Add `const MAX_DIFF_LENGTH: usize = 8000;`
   - Add `truncate_diff(diff: &str) -> String`
   - If diff.len() <= MAX_DIFF_LENGTH, return unchanged
   - Else return `diff[..MAX_DIFF_LENGTH] + "\n... (diff truncated)"`

2. Add change summary parsing:
   - Add `parse_change_summary(stat: &str, name_status: &str) -> String`
   - Parse file count from name_status (count lines)
   - Parse lines from stat using regex (e.g., "10 insertions(+), 5 deletions(-)")
   - Use existing regex + once_cell dependencies
   - Return formatted summary: "Files changed: X\nLines added: Y\nLines removed: Z"

3. Update `build_prompt()`:
   - Call `truncate_diff()` on diff content before adding to prompt
   - Add CHANGE SUMMARY section after instructions, before diff sections
   - Insert `parse_change_summary()` output in this section

4. Write unit tests:
   - Test truncation at boundary (7999, 8000, 8001 chars)
   - Test truncation message appended correctly
   - Test change summary parsing from various stat formats
   - Test change summary parsing from name_status
   - Test full prompt includes summary section

**Acceptance Criteria**:
- [ ] `MAX_DIFF_LENGTH` constant set to 8000
- [ ] `truncate_diff()` function works correctly at boundaries
- [ ] Truncation message "... (diff truncated)" appended when needed
- [ ] Change summary section added to prompt template
- [ ] File count parsed correctly from name_status
- [ ] Lines added/removed parsed from stat output
- [ ] Unit tests cover truncation edge cases
- [ ] Unit tests cover various stat output formats
- [ ] Manual test: large diff (>8000 chars) gets truncated

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Functions over structs (free functions for truncate_diff, parse_change_summary)
- No complex diff analysis (only file count, line counts - per patterns.md anti-patterns)
- Use existing regex + once_cell for parsing

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
cargo test prompt::tests
cargo clippy -- -D warnings
cargo fmt -- --check
```

### Task 2.3: Lefthook Safety - Existing Hook Detection

**Files**:
- src/hooks/managers.rs

**Complexity**: S (2h)

**Dependencies**: None

**Description**:
Add safety check to lefthook installer to detect existing prepare-commit-msg hooks and warn users instead of silently overwriting their configuration.

**Implementation Steps**:

1. In `install_lefthook()` function:
   - After reading lefthook config file (if exists)
   - Check if `existing_config.contains("prepare-commit-msg:")`
   - If found, print warning message to stderr
   - Return `Ok(())` without modifying config (skip installation)

2. Add warning message format:
   - Use console crate for styling (already in dependencies)
   - Message: "Warning: lefthook.yml already has prepare-commit-msg hook, skipping installation"
   - Suggest manual configuration

3. Write unit tests:
   - Test that function returns Ok without writing when hook exists
   - Test that function proceeds normally when hook doesn't exist
   - Test warning message is generated (capture stderr if possible)

**Acceptance Criteria**:
- [ ] Detection checks for "prepare-commit-msg:" in config
- [ ] Warning message printed to stderr when hook exists
- [ ] Installation skipped (returns Ok) when hook exists
- [ ] Installation proceeds normally when hook doesn't exist
- [ ] Tests verify detection logic
- [ ] Manual test: existing lefthook config is not overwritten

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Error handling: return Ok() on skip, not an error (per anyhow patterns)
- See hooks module responsibilities in architecture.md

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
cargo test hooks::tests
cargo clippy -- -D warnings
cargo fmt -- --check
```

---

## Phase 3: Integration - Agent Refactor & CLI Updates

**Strategy**: sequential
**Reason**: These tasks depend on Phase 1's shared infrastructure and Phase 2's feature implementations

### Task 3.1: Agent Files Refactor & Rust Idioms

**Files**:
- src/agents/claude.rs
- src/agents/codex.rs
- src/agents/gemini.rs
- src/types.rs
- src/cli.rs

**Complexity**: L (6h)

**Dependencies**: task-1.1

**Description**:
Refactor all agent files to use shared infrastructure from Phase 1, reducing each from ~130 lines to ~15-20 lines. Add Rust idiomatic trait implementations to ConventionalCommit and agent structs. Update CLI to use centralized AgentName methods.

**Implementation Steps**:

1. Refactor `src/agents/claude.rs`:
   - Import `check_command_exists`, `run_command_with_stdin`, `AGENT_TIMEOUT` from parent module
   - Simplify `execute()` to: check command exists, timeout wrapper around run_command_with_stdin
   - Remove duplicate implementations
   - Add `#[derive(Default)]` to ClaudeAgent
   - Target ~15 lines for the entire file

2. Refactor `src/agents/codex.rs`:
   - Same pattern as Claude
   - Add `#[derive(Default)]` to CodexAgent
   - Adjust arguments for codex CLI specifics

3. Refactor `src/agents/gemini.rs`:
   - Same pattern as Claude
   - Add `#[derive(Default)]` to GeminiAgent
   - Adjust arguments for gemini CLI specifics

4. Add Rust idioms to `src/types.rs` ConventionalCommit:
   - Add `#[must_use = "validation result should be checked"]` to validate()
   - Implement `AsRef<str>` trait
   - Implement `Deref<Target=str>` trait
   - Add doc comments explaining trade-offs

5. Update `src/cli.rs`:
   - Replace inline agent name matches with `agent_name.display_name()`
   - Use in signature generation: `format!("ðŸ¤– Generated with {} via commitment", agent_name.display_name())`
   - Add staged files display function: `display_staged_files(name_status: &str)`
   - Call before spinner: `if !args.quiet && !args.message_only { display_staged_files(&diff.name_status); }`
   - Format: "Staged changes:\n  M  src/file.rs\n  A  src/new.rs"

6. Write/update tests:
   - Test each agent's execute() with shared infrastructure
   - Test ConventionalCommit Deref works (.len(), .contains())
   - Test ConventionalCommit AsRef works with generic functions
   - Test display_staged_files formatting
   - Test CLI respects --quiet and --message-only flags

**Acceptance Criteria**:
- [ ] claude.rs reduced to ~15-20 lines
- [ ] codex.rs reduced to ~15-20 lines
- [ ] gemini.rs reduced to ~15-20 lines
- [ ] All agent files use shared utilities from agents/mod.rs
- [ ] Agent structs derive Default
- [ ] ConventionalCommit::validate() has #[must_use] attribute
- [ ] ConventionalCommit implements AsRef<str>
- [ ] ConventionalCommit implements Deref<Target=str>
- [ ] cli.rs uses AgentName::display_name() instead of inline matches
- [ ] Staged files displayed before spinner (respecting flags)
- [ ] All public functions have doc comments
- [ ] Tests verify agent refactor works
- [ ] Tests verify ConventionalCommit traits work
- [ ] Manual test: commit flow works end-to-end with refactored agents

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Enum dispatch for agents (not trait objects - see patterns.md)
- Agent timeout pattern (async with timeout wrapper)
- Newtype validation pattern (ConventionalCommit)
- CLI layer responsibilities (display, formatting)
- See architecture.md for layer boundaries

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
cargo test agents::tests
cargo test types::tests
cargo test cli::tests
cargo clippy -- -D warnings
cargo fmt -- --check
```

### Task 3.2: Integration Testing & Documentation

**Files**:
- tests/integration_tests.rs (new)
- README.md
- CHANGELOG.md (new)

**Complexity**: M (4h)

**Dependencies**: task-1.1, task-2.1, task-2.2, task-2.3, task-3.1

**Description**:
Add integration tests verifying all features work together end-to-end. Update documentation to reflect new features and improvements.

**Implementation Steps**:

1. Create `tests/integration_tests.rs`:
   - Test full generation flow with truncated diff
   - Test change summary appears in prompt
   - Test staged files display
   - Test git diff flags are used
   - Use MockGitProvider for controlled test scenarios

2. Update README.md:
   - Add mention of diff truncation (8000 char limit)
   - Add mention of optimized git diff flags
   - Add mention of change summary in prompts
   - Add screenshot/example of staged files display (optional)

3. Create CHANGELOG.md:
   - Add version entry for this release
   - List all new features (FR1-FR5)
   - List code quality improvements (DRY compliance)
   - List Rust idioms added (must_use, AsRef, Deref, Default)

4. Run full test suite:
   - `cargo test` (all tests)
   - `cargo clippy -- -D warnings`
   - `cargo fmt -- --check`
   - Manual testing with real git repo

**Acceptance Criteria**:
- [ ] Integration tests cover full generation flow
- [ ] Integration tests verify truncation works
- [ ] Integration tests verify change summary in prompt
- [ ] Integration tests verify git diff flags
- [ ] README.md updated with new features
- [ ] CHANGELOG.md created with complete feature list
- [ ] All tests pass (`cargo test`)
- [ ] No clippy warnings
- [ ] Code formatted correctly
- [ ] Manual test: generate commit with >8000 char diff
- [ ] Manual test: staged files display before generation
- [ ] Manual test: lefthook doesn't overwrite existing config

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Integration tests in tests/ directory (see testing.md)
- Trait-based mocking (MockGitProvider)
- See testing.md for test organization

**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
cargo test
cargo test --test integration_tests
cargo clippy -- -D warnings
cargo fmt -- --check
cargo build --release  # Final build check
```

---

## Summary

**Task Breakdown:**
- Phase 1: 1 task (4h) - Foundation
- Phase 2: 3 tasks (9h) - Parallel features (saves 7h vs sequential)
- Phase 3: 2 tasks (10h) - Integration

**Complexity Distribution:**
- S (1-2h): 1 task (9%)
- M (3-5h): 4 tasks (57%)
- L (5-7h): 1 task (14%)
- XL (>8h): 0 tasks (0%)

**Execution Strategy:**
1. Complete Task 1.1 first (foundation)
2. Execute Phase 2 tasks in parallel (7h time savings)
3. Execute Phase 3 tasks sequentially (depend on prior work)

**Total Time:**
- Sequential: 23h
- With Parallelization: 16h
- **Savings: 7h (30% faster)**
