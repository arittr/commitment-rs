---
runId: 25ec7e
feature: commitment-rs-port
created: 2025-12-09
status: ready
---

# Feature: commitment-rs Port - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/25ec7e-commitment-rs-port/spec.md
> **Created:** 2025-12-09

## Execution Summary

- **Total Tasks**: 8
- **Total Phases**: 5
- **Sequential Time**: 33h
- **Parallel Time**: 24h
- **Time Savings**: 9h (27% faster)

**Parallel Opportunities:**

- Phase 2: 3 tasks (9h saved)

**Task Complexity Distribution:**

- L (5-8h): 4 tasks
- M (3-5h): 4 tasks
- S (1-2h): 0 tasks

---

## Phase 1: Project Foundation

**Strategy**: Sequential
**Reason**: Scaffolding and foundational types must exist before implementation can begin
**Tasks**: 2
**Duration**: 6h sequential

### Task 1: Project Scaffolding

**Files**:
- `Cargo.toml`
- `src/main.rs`
- `src/lib.rs`
- `src/types.rs`
- `src/error.rs`
- `src/git.rs`
- `src/prompt.rs`
- `src/cli.rs`
- `src/agents/mod.rs`
- `src/agents/claude.rs`
- `src/hooks/mod.rs`
- `src/hooks/managers.rs`
- `.gitignore`
- `README.md` (minimal)

**Complexity**: M (3h)

**Dependencies**: None

**Description**:
Initialize Rust project with proper workspace structure, dependencies, and module skeleton. This establishes the foundation for all subsequent work.

Creates all module files with stub implementations (empty traits, placeholder structs), allowing other tasks to build in parallel.

**Implementation Steps**:

1. Initialize with `cargo init --name commitment` (if not already done)
2. Configure `Cargo.toml` with dependencies:
   - tokio (features: rt-multi-thread, macros, process)
   - clap (features: derive)
   - thiserror, anyhow
   - console, indicatif
   - regex, once_cell
   - serde, serde_json, serde_yaml
   - Dev dependencies: tokio test-util
3. Set edition = "2024" and configure release profile with LTO
4. Create module file structure with minimal exports
5. Add basic `#[tokio::main]` in main.rs that prints "commitment-rs"
6. Create `.gitignore` (Rust standard: `/target`, `Cargo.lock`, etc.)
7. Add minimal README with project description
8. Verify: `cargo check` passes

**Acceptance Criteria**:

- [ ] `cargo check` passes without errors
- [ ] All dependencies resolve correctly
- [ ] Module structure matches architecture.md spec
- [ ] `cargo run` executes and prints placeholder message
- [ ] Release profile configured with `lto = true`

**Constitution References**:

> **Architecture**: Follow @docs/constitutions/current/architecture.md for layer boundaries
> **Tech Stack**: Use exact versions and features from @docs/constitutions/current/tech-stack.md
> **Patterns**: Follow module organization from @docs/constitutions/current/patterns.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo check
```

---

### Task 2: Core Types and Errors

**Files**:
- `src/types.rs` (complete implementation)
- `src/error.rs` (complete implementation)

**Complexity**: M (3h)

**Dependencies**: task-1-project-scaffolding

**Description**:
Implement foundational domain types and error hierarchy that all other modules depend on. This includes validated newtypes, enums for closed sets, and structured error types using thiserror.

This task establishes type safety and error handling patterns for the entire codebase.

**Implementation Steps**:

1. Implement `AgentName` enum (Claude, Codex, Gemini) with:
   - `FromStr` trait for parsing from CLI strings
   - `Display` trait for error messages
   - Unit tests for valid/invalid parsing
2. Implement `ConventionalCommit` newtype with:
   - Private `raw: String` field
   - `validate()` constructor with regex checking
   - `as_str()` getter method
   - Regex pattern for conventional commit format (type, scope, description)
   - Unit tests for validation edge cases
3. Implement `StagedDiff` struct (plain data carrier, no validation):
   - Fields: `stat`, `name_status`, `diff` (all String)
   - Derive Clone, Debug
4. Implement error types with thiserror:
   - `AgentError` (NotFound, ExecutionFailed, Timeout, InvalidResponse)
   - `GitError` (NoStagedChanges, CommandFailed, WorktreeResolution)
   - `GeneratorError` (wraps AgentError, GitError, ValidationError)
   - Proper `#[source]` and `#[from]` attributes
5. Add comprehensive unit tests in `#[cfg(test)]` modules

**Acceptance Criteria**:

- [ ] `AgentName::from_str()` parses "claude", "codex", "gemini" correctly
- [ ] `AgentName::from_str()` rejects invalid names with clear error
- [ ] `ConventionalCommit::validate()` accepts "feat: add X", "fix(scope): Y"
- [ ] `ConventionalCommit::validate()` rejects non-conventional formats
- [ ] All error types implement std::error::Error via thiserror
- [ ] `cargo test` passes all unit tests
- [ ] `cargo clippy` has no warnings

**Constitution References**:

> **Patterns**: Follow newtype pattern from @docs/constitutions/current/patterns.md
> **Patterns**: Use enum for closed sets (AgentName)
> **Patterns**: Use thiserror for domain errors
> **Testing**: Co-locate tests using #[cfg(test)] modules per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test types:: error::
```

---

## Phase 2: Core Modules

**Strategy**: Parallel
**Reason**: Git, Prompt, and Agent modules are independent - only depend on types/errors
**Tasks**: 3
**Duration**: 18h sequential, 6h parallel (saves 12h)

### Task 3: Git Module

**Files**:
- `src/git.rs` (complete implementation)

**Complexity**: L (6h)

**Dependencies**: task-2-core-types-and-errors

**Description**:
Implement Git operations layer with trait-based abstraction for testability. Handles all git command execution, output parsing, and worktree resolution.

Provides sync API since git operations are fast and local. Implements both production and test providers.

**Implementation Steps**:

1. Define `GitProvider` trait with methods:
   - `get_staged_diff(&self) -> Result<StagedDiff, GitError>`
   - `has_staged_changes(&self) -> Result<bool, GitError>`
   - `commit(&self, message: &str) -> Result<(), GitError>`
2. Implement `RealGitProvider` struct:
   - Field: `cwd: PathBuf` (working directory)
   - Constructor: `new(cwd: PathBuf) -> Self`
3. Implement `get_staged_diff()`:
   - Execute `git diff --cached --stat`
   - Execute `git diff --cached --name-status`
   - Execute `git diff --cached`
   - Parse all outputs into `StagedDiff` struct
   - Return `GitError::NoStagedChanges` if diff is empty
4. Implement `has_staged_changes()`:
   - Execute `git diff --cached --quiet`
   - Return true/false based on exit code
5. Implement `commit()`:
   - Execute `git commit -m "<message>"`
   - Handle command failures with detailed stderr
6. Add helper for running git commands with proper error handling
7. Add worktree support (parse `.git` file for `gitdir:` reference)
8. Implement `MockGitProvider` in test module:
   - Builder pattern for configuring mock responses
   - Methods: `with_diff()`, `with_no_changes()`, etc.
9. Add comprehensive unit tests:
   - Test diff parsing with various formats
   - Test error cases (no changes, command failure)
   - Test worktree resolution logic

**Acceptance Criteria**:

- [ ] `RealGitProvider::get_staged_diff()` correctly executes and parses git output
- [ ] Returns `GitError::NoStagedChanges` when no files staged
- [ ] `commit()` executes git commit with provided message
- [ ] Handles git worktrees by resolving `.git` file's gitdir reference
- [ ] `MockGitProvider` enables testing without real git commands
- [ ] Unit tests verify parsing and error handling
- [ ] `cargo test git::` passes all tests

**Constitution References**:

> **Architecture**: Git module is sync (local operations) per @docs/constitutions/current/architecture.md
> **Patterns**: Use trait for abstraction boundary per @docs/constitutions/current/patterns.md
> **Testing**: Manual trait-based mocking per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test git::
```

---

### Task 4: Prompt Module

**Files**:
- `src/prompt.rs` (complete implementation)

**Complexity**: M (3h)

**Dependencies**: task-2-core-types-and-errors

**Description**:
Implement prompt construction for AI agents. Simple template-based approach - no complex diff analysis (AI handles that).

Builds formatted prompt with file statistics, name/status list, and full diff content.

**Implementation Steps**:

1. Implement `build_prompt(diff: &StagedDiff) -> String` function:
   - Template structure:
     - Instructions for conventional commit format
     - Request for commit type (feat, fix, docs, etc.)
     - File statistics section (`diff.stat`)
     - File name/status section (`diff.name_status`)
     - Full diff section (`diff.diff`)
   - Use markers: `<<<COMMIT_MESSAGE_START>>>` and `<<<COMMIT_MESSAGE_END>>>`
   - Include format instructions (type, optional scope, description)
2. Add helper function for formatting sections with clear headers
3. No diff analysis logic - just template formatting
4. Add unit tests:
   - Test prompt format with sample diff
   - Test empty diff handling
   - Test marker presence in output
   - Verify all sections included

**Acceptance Criteria**:

- [ ] `build_prompt()` includes all three diff sections (stat, name-status, diff)
- [ ] Output contains clear instructions for conventional commit format
- [ ] Includes marker tags for response extraction
- [ ] Handles empty diff sections gracefully
- [ ] Unit tests verify prompt structure
- [ ] `cargo test prompt::` passes all tests

**Constitution References**:

> **Patterns**: Use free functions over methods per @docs/constitutions/current/patterns.md
> **Patterns**: No complex diff analysis - let AI handle it per @docs/constitutions/current/patterns.md
> **Testing**: Co-locate unit tests per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test prompt::
```

---

### Task 5: Agent System (Claude Only)

**Files**:
- `src/agents/mod.rs` (complete implementation)
- `src/agents/claude.rs` (complete implementation)

**Complexity**: L (6h)

**Dependencies**: task-2-core-types-and-errors

**Description**:
Implement agent system with enum dispatch pattern and response cleaning pipeline. Includes Claude agent implementation with async process execution.

This establishes the agent abstraction and cleaning logic that Codex/Gemini will reuse later.

**Implementation Steps**:

1. Define `Agent` enum in `agents/mod.rs`:
   - Variant: `Claude(ClaudeAgent)`
   - Placeholder variants: `Codex(CodexAgent)`, `Gemini(GeminiAgent)` (not implemented yet)
2. Implement `Agent::execute()` with enum dispatch:
   - Match on variants, call inner agent's execute method
3. Implement `clean_ai_response(raw: &str) -> String`:
   - Step 1: Extract between markers (if present)
   - Step 2: Remove markdown code blocks (` ```...``` `)
   - Step 3: Remove preambles ("Here is the commit message:", etc.)
   - Step 4: Remove thinking tags (`<thinking>...</thinking>`)
   - Step 5: Collapse 3+ newlines to 2
   - Step 6: Trim whitespace
   - Use regex with once_cell::Lazy for performance
4. Implement `From<AgentName> for Agent` conversion
5. Implement `ClaudeAgent` in `agents/claude.rs`:
   - Struct: `pub struct ClaudeAgent;`
   - Method: `pub async fn execute(&self, prompt: &str) -> Result<String, AgentError>`
   - Implementation:
     - Check `claude` CLI exists in PATH
     - Use `tokio::process::Command`
     - Args: `["--print"]` (for non-interactive output)
     - Stdin: pipe prompt
     - Timeout: 120 seconds
     - Return stdout on success
     - Map errors to `AgentError::NotFound`, `AgentError::ExecutionFailed`, `AgentError::Timeout`
6. Add helper: `check_command_exists(cmd: &str) -> Result<(), AgentError>`
7. Add helper: `run_command_with_timeout()` for subprocess management
8. Add comprehensive unit tests:
   - Test `clean_ai_response()` with various inputs
   - Test each cleaning step independently
   - Test marker extraction
   - Mock tests for agent execution (use test utilities)
9. Add integration test for full cleaning pipeline

**Acceptance Criteria**:

- [ ] `Agent::execute()` dispatches to correct agent implementation
- [ ] `clean_ai_response()` correctly removes markdown, preambles, thinking tags
- [ ] `clean_ai_response()` extracts content between markers when present
- [ ] `ClaudeAgent::execute()` spawns subprocess with correct args
- [ ] Returns `AgentError::NotFound` when claude CLI not in PATH
- [ ] Implements 120-second timeout for agent execution
- [ ] Unit tests verify all cleaning steps
- [ ] `cargo test agents::` passes all tests

**Constitution References**:

> **Patterns**: Use enum dispatch, not trait objects per @docs/constitutions/current/patterns.md
> **Patterns**: Agent execution is async per @docs/constitutions/current/patterns.md
> **Tech Stack**: Use tokio::process::Command per @docs/constitutions/current/tech-stack.md
> **Testing**: Test cleaning pipeline thoroughly per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test agents::
```

---

## Phase 3: Core Orchestration

**Strategy**: Sequential
**Reason**: Core lib depends on all modules from Phase 2 completing
**Tasks**: 1
**Duration**: 4h sequential

### Task 6: Core Library (generate_commit_message)

**Files**:
- `src/lib.rs` (complete implementation)

**Complexity**: M (4h)

**Dependencies**: task-3-git-module, task-4-prompt-module, task-5-agent-system-claude-only

**Description**:
Implement core orchestration function that ties together Git → Prompt → Agent → Validation. This is the primary public API of the library.

Provides clean functional interface with proper error propagation and type safety.

**Implementation Steps**:

1. Define public API in `lib.rs`:
   - Export key types: `ConventionalCommit`, `Agent`, `AgentName`, `StagedDiff`, `GitProvider`
   - Export errors: `AgentError`, `GitError`, `GeneratorError`
2. Implement `generate_commit_message()`:
   - Signature: `pub async fn generate_commit_message(git: &impl GitProvider, agent: &Agent, signature: Option<&str>) -> Result<ConventionalCommit, GeneratorError>`
   - Steps:
     - Check `git.has_staged_changes()` → error if false
     - Get `git.get_staged_diff()` → `StagedDiff`
     - Build prompt with `build_prompt(&diff)`
     - Execute agent with `agent.execute(&prompt).await`
     - Clean response with `clean_ai_response(&raw_output)`
     - Append signature if provided (e.g., "Co-Authored-By: ...")
     - Validate with `ConventionalCommit::validate(&cleaned)`
     - Return validated commit message
3. Add comprehensive integration tests:
   - Use `MockGitProvider` with sample diffs
   - Mock agent (or use test fixtures for cleaned responses)
   - Test full flow: diff → prompt → cleaned → validated
   - Test error propagation (no changes, agent failure, validation failure)
   - Test signature appending
4. Add documentation comments explaining the orchestration flow

**Acceptance Criteria**:

- [ ] `generate_commit_message()` orchestrates full flow correctly
- [ ] Returns `GeneratorError` when no staged changes exist
- [ ] Properly propagates errors from git, agent, and validation layers
- [ ] Appends signature when provided
- [ ] Integration tests verify end-to-end flow with mocks
- [ ] Public API exports all necessary types
- [ ] `cargo test --lib` passes all tests
- [ ] `cargo doc --no-deps` generates clean documentation

**Constitution References**:

> **Architecture**: Core layer orchestrates git → prompt → agent per @docs/constitutions/current/architecture.md
> **Patterns**: Use free function, not struct per @docs/constitutions/current/patterns.md
> **Patterns**: Generic over GitProvider trait per @docs/constitutions/current/patterns.md
> **Testing**: Integration tests in lib.rs verify full flow per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test --lib
cargo doc --no-deps
```

---

## Phase 4: CLI and UX

**Strategy**: Sequential
**Reason**: CLI depends on core library being complete
**Tasks**: 1
**Duration**: 5h sequential

### Task 7: CLI Layer with UX Polish

**Files**:
- `src/cli.rs` (complete implementation)
- `src/main.rs` (complete implementation)

**Complexity**: L (5h)

**Dependencies**: task-6-core-library-generate_commit_message

**Description**:
Implement command-line interface with clap, user-friendly error messages, and terminal UX (spinner, colors). This is the user-facing layer that wraps the core library.

Includes argument parsing, progress indicators, error formatting with helpful hints, and proper exit codes.

**Implementation Steps**:

1. Define CLI structure in `cli.rs` using clap derive:
   - Main struct: `Cli` with subcommands
   - Command: `Generate` (default) with args:
     - `--agent <NAME>` (default: claude)
     - `--dry-run` (bool)
     - `--message-only` (bool)
     - `--quiet` (bool)
     - `--verbose` (bool)
     - `--cwd <PATH>` (default: .)
   - Command: `Init` with args:
     - `--hook-manager <MANAGER>` (optional, auto-detect if not provided)
     - `--agent <NAME>` (default: claude)
2. Implement `run_generate()` function:
   - Parse agent name to `AgentName` enum
   - Create `RealGitProvider` with cwd
   - Create `Agent` from agent name
   - Show spinner with indicatif: "Generating commit message..."
   - Call `generate_commit_message()`
   - Stop spinner
   - If `--message-only`: print raw message only
   - If `--dry-run`: print formatted message with colors
   - Otherwise: commit with `git.commit()` and show success message
3. Implement error formatting with helpful hints:
   - Match on error types
   - `AgentError::NotFound`: Show installation URL
   - `GitError::NoStagedChanges`: Suggest "git add"
   - Use `console::style()` for colored output (red for errors, green for success)
4. Implement `run_init()` stub (minimal - full implementation in Phase 5):
   - Print placeholder message: "Hook initialization coming in Phase 5"
5. Update `main.rs`:
   - `#[tokio::main]` async fn main
   - Parse `Cli` with clap
   - Call appropriate run function
   - Handle errors and set exit codes (0 for success, 1 for errors)
6. Add progress indicators:
   - Spinner while waiting for AI
   - Success/error symbols (✓/✗)
   - Only show when not `--quiet` or `--message-only`
7. Add integration tests:
   - Test argument parsing
   - Test dry-run mode (no commit)
   - Test message-only mode (no formatting)
   - Test error message formatting

**Acceptance Criteria**:

- [ ] `cargo run -- --help` displays full help text
- [ ] `--agent` accepts "claude", "codex", "gemini"
- [ ] `--dry-run` prints message without committing
- [ ] `--message-only` outputs raw message for piping
- [ ] Spinner shows during AI generation (unless --quiet)
- [ ] Error messages include helpful installation/fix hints
- [ ] Success message uses green color, errors use red
- [ ] `--cwd` changes working directory correctly
- [ ] Exit code 0 on success, 1 on error
- [ ] `cargo build --release` produces working binary

**Constitution References**:

> **Architecture**: CLI layer formats errors, shows progress per @docs/constitutions/current/architecture.md
> **Patterns**: Use anyhow::Result at CLI boundary per @docs/constitutions/current/patterns.md
> **Tech Stack**: Use clap derive, console, indicatif per @docs/constitutions/current/tech-stack.md
> **Testing**: Test CLI argument parsing and error formatting

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test cli::
cargo build --release
./target/release/commitment --help
```

---

## Phase 5: Extensions

**Strategy**: Parallel
**Reason**: Hooks and additional agents are independent features
**Tasks**: 2
**Duration**: 14h sequential, 7h parallel (saves 7h)

### Task 8: Hook Manager System

**Files**:
- `src/hooks/mod.rs` (complete implementation)
- `src/hooks/managers.rs` (complete implementation)
- `src/cli.rs` (update `run_init()` with full implementation)

**Complexity**: L (7h)

**Dependencies**: task-7-cli-layer-with-ux-polish

**Description**:
Implement hook detection and installation system supporting lefthook, husky, simple-git-hooks, and plain git hooks. Includes git worktree support for hook resolution.

Provides automatic detection with manual override, and creates prepare-commit-msg hooks that call commitment.

**Implementation Steps**:

1. Define `HookManager` enum in `hooks/mod.rs`:
   - Variants: `Lefthook`, `Husky`, `SimpleGitHooks`, `PlainGit`
   - Derive: Debug, Clone, Copy
   - Implement `FromStr` for CLI parsing
   - Implement `Display` for output
2. Implement `detect_hook_manager(cwd: &Path) -> Option<HookManager>`:
   - Check for lefthook config files (lefthook.yml, .lefthook.yml, etc.)
   - Check for .husky directory
   - Check for simple-git-hooks in package.json
   - Return first match, or None (will use PlainGit as fallback)
3. Implement manager-specific installation in `hooks/managers.rs`:
   - `install_lefthook(cwd: &Path, agent: &AgentName) -> Result<(), HookError>`
     - Update/create lefthook.yml
     - Add prepare-commit-msg hook entry
     - Command: `commitment --agent <agent>`
   - `install_husky(cwd: &Path, agent: &AgentName) -> Result<(), HookError>`
     - Create/update .husky/prepare-commit-msg script
     - Make executable
     - Call commitment with specified agent
   - `install_simple_git_hooks(cwd: &Path, agent: &AgentName) -> Result<(), HookError>`
     - Update package.json with hooks config
     - Use serde_json for parsing/writing
   - `install_plain_git(cwd: &Path, agent: &AgentName) -> Result<(), HookError>`
     - Resolve .git directory (handle worktrees via gitdir: reference)
     - Create .git/hooks/prepare-commit-msg script
     - Make executable
     - Call commitment with specified agent
4. Implement unified `install_hook()` function:
   - Takes manager (detected or specified), cwd, agent
   - Dispatches to correct installation function
   - Returns clear error messages for each failure mode
5. Implement worktree resolution:
   - Helper: `resolve_git_dir(cwd: &Path) -> Result<PathBuf, HookError>`
   - If `.git` is file, read and parse `gitdir:` reference
   - If `.git` is directory, use directly
6. Update `run_init()` in `cli.rs`:
   - Detect hook manager (or use specified)
   - Print detection result
   - Call `install_hook()`
   - Show success message with manager used
7. Add comprehensive tests:
   - Test detection logic with mock file structures
   - Test each manager's installation (mock file writes)
   - Test worktree resolution with sample .git file
   - Test error cases (no write permission, invalid config)

**Acceptance Criteria**:

- [ ] `detect_hook_manager()` correctly identifies all four manager types
- [ ] Lefthook installation updates/creates lefthook.yml correctly
- [ ] Husky installation creates executable .husky/prepare-commit-msg
- [ ] simple-git-hooks updates package.json via serde_json
- [ ] Plain git hooks resolve worktree .git files correctly
- [ ] `commitment init` detects manager and installs hook
- [ ] `commitment init --hook-manager lefthook` overrides detection
- [ ] Hook scripts call `commitment --agent <specified>`
- [ ] Tests verify all installation paths
- [ ] `cargo test hooks::` passes all tests

**Constitution References**:

> **Architecture**: Hooks module is isolated per @docs/constitutions/current/architecture.md
> **Patterns**: Use enum for closed set of managers per @docs/constitutions/current/patterns.md
> **Tech Stack**: Use serde_json/serde_yaml for config parsing per @docs/constitutions/current/tech-stack.md
> **Testing**: Mock file operations for testing per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test hooks::
cargo run -- init --help
```

---

### Task 9: Additional AI Agents (Codex, Gemini)

**Files**:
- `src/agents/codex.rs` (new file)
- `src/agents/gemini.rs` (new file)
- `src/agents/mod.rs` (update enum with new variants)
- `src/types.rs` (AgentName already has variants, just ensure complete)

**Complexity**: L (7h)

**Dependencies**: task-7-cli-layer-with-ux-polish

**Description**:
Implement Codex and Gemini agent backends to complement Claude. Each has different CLI invocation patterns - Codex uses stdin like Claude, Gemini uses prompt argument.

Reuses existing Agent enum infrastructure and cleaning pipeline from Task 5.

**Implementation Steps**:

1. Implement `CodexAgent` in `agents/codex.rs`:
   - Struct: `pub struct CodexAgent;`
   - Method: `pub async fn execute(&self, prompt: &str) -> Result<String, AgentError>`
   - CLI: `codex exec --skip-git-repo-check`
   - Input: stdin (pipe prompt)
   - Timeout: 120 seconds
   - Error mapping like ClaudeAgent
2. Implement `GeminiAgent` in `agents/gemini.rs`:
   - Struct: `pub struct GeminiAgent;`
   - Method: `pub async fn execute(&self, prompt: &str) -> Result<String, AgentError>`
   - CLI: `gemini -p "<prompt>"`
   - Input: command-line argument (not stdin)
   - Escape prompt properly for shell argument
   - Timeout: 120 seconds
   - Error mapping like ClaudeAgent
3. Update `Agent` enum in `agents/mod.rs`:
   - Remove placeholder comments from Codex/Gemini variants
   - Update `execute()` match to handle all three variants
   - Update `From<AgentName> for Agent` to construct new agents
   - Update `name()` method to return correct agent name
4. Add unit tests for each new agent:
   - Test command construction
   - Test error handling (not found, timeout, execution failed)
   - Mock subprocess execution for testing
5. Add integration test verifying all three agents work through common interface
6. Update documentation to show all supported agents

**Acceptance Criteria**:

- [ ] `CodexAgent::execute()` calls `codex exec --skip-git-repo-check` with stdin
- [ ] `GeminiAgent::execute()` calls `gemini -p "<prompt>"` with escaped argument
- [ ] Both agents return `AgentError::NotFound` when CLI not in PATH
- [ ] Both agents implement 120-second timeout
- [ ] `Agent::execute()` dispatches to all three agent types correctly
- [ ] `--agent codex` and `--agent gemini` work from CLI
- [ ] Tests verify all three agent implementations
- [ ] `cargo test agents::` passes for all agents
- [ ] Documentation lists all three supported agents

**Constitution References**:

> **Patterns**: Enum dispatch handles all agents uniformly per @docs/constitutions/current/patterns.md
> **Patterns**: Async execution for external processes per @docs/constitutions/current/patterns.md
> **Architecture**: Agents module is independent per @docs/constitutions/current/architecture.md
> **Testing**: Test each agent implementation per @docs/constitutions/current/testing.md

**Quality Gates**:

```bash
cargo fmt
cargo clippy -- -D warnings
cargo test agents::
cargo run -- --agent codex --help
cargo run -- --agent gemini --help
```

---

## Verification & Success Criteria

After all phases complete, verify the implementation meets spec requirements:

### Functional Verification

```bash
# Test commit generation (requires claude CLI)
git add .
cargo run -- --dry-run

# Test with different agents
cargo run -- --agent codex --dry-run
cargo run -- --agent gemini --dry-run

# Test message-only mode
cargo run -- --message-only

# Test hook installation
cargo run -- init
cargo run -- init --hook-manager lefthook
```

### Quality Verification

```bash
# All tests pass
cargo test

# No clippy warnings
cargo clippy -- -D warnings

# Code formatted
cargo fmt -- --check

# Documentation builds
cargo doc --no-deps

# Release binary size
cargo build --release
ls -lh target/release/commitment  # Should be < 5MB
```

### Constitution Compliance

- [ ] Architecture follows layered design (CLI → Core → Git/Agents)
- [ ] No upward dependencies (lower layers don't import upper)
- [ ] Enum dispatch used for agents (no trait objects)
- [ ] Newtype pattern for ConventionalCommit validation
- [ ] Sync git, async agents
- [ ] thiserror for domain errors, anyhow for CLI
- [ ] Manual trait-based mocking (no mockall)
- [ ] Co-located unit tests in #[cfg(test)] modules

### Self-Dogfooding

```bash
# Use commitment-rs to commit its own changes
git add .
cargo run
# Verify it generates good conventional commits for Rust code
```

---

## Notes for Execution

### Recommended Subagent Workflow

Use `/spectacular:execute` to run this plan:

```bash
/spectacular:execute @specs/25ec7e-commitment-rs-port/plan.md
```

This will:
- Create worktrees for parallel phases
- Spawn subagents for each task
- Merge branches sequentially across phases
- Clean up worktrees after completion

### Parallel Phase Strategy

**Phase 2** and **Phase 5** can parallelize effectively:
- Phase 2: Git, Prompt, Agent modules build independently
- Phase 5: Hooks and additional agents are independent features

This saves ~9 hours of sequential execution time.

### Testing During Development

Run tests incrementally:

```bash
# After each task
cargo test <module>::

# Before marking task complete
cargo test
cargo clippy -- -D warnings
cargo fmt
```

### Constitution Adherence

Every task **MUST** follow:
- @docs/constitutions/current/architecture.md (layer boundaries)
- @docs/constitutions/current/patterns.md (enum dispatch, newtypes, errors)
- @docs/constitutions/current/tech-stack.md (exact dependencies)
- @docs/constitutions/current/testing.md (test patterns)

### Expected Challenges

1. **Agent timeout handling**: Requires tokio timeout wrapper
2. **Response cleaning pipeline**: Order matters, test each step
3. **Worktree resolution**: Parse .git file correctly
4. **Hook manager detection**: File existence checks need careful ordering
5. **Binary size**: Use `lto = true` in release profile

### Post-Implementation

After plan execution completes:
1. Run full test suite: `cargo test`
2. Build release binary: `cargo build --release`
3. Test self-dogfooding: use commitment-rs for its own commits
4. Create PR with all changes
5. Document any deviations from plan in PR description
